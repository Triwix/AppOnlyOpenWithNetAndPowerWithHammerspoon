{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande;\f2\fnil\fcharset77 ZapfDingbatsITC;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww26660\viewh16560\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 -- Configuration\
local appName = \'93YOUR_APP\'94\
local requiredWiFi = \'93YOUR_WIFI\'94\
\
-- Track last known state to prevent redundant actions\
local lastShouldBeRunning = nil\
\
-- Debug helper\
local function log(msg)\
    print(string.format("[%s] %s", os.date("%H:%M:%S"), msg))\
end\
\
-- Simple notification helper\
local function notify(msg)\
    hs.notify.new(\{ title = "Hammerspoon", informativeText = msg \}):send()\
end\
\
-- Get WiFi name using multiple methods\
local function getWiFiNetwork()\
    -- Method 1: Standard API (requires Location Services permission)\
    local network = hs.wifi.currentNetwork()\
    if network then return network end\
    \
    -- Method 2: Check interface details\
    local interfaces = hs.wifi.interfaces()\
    if interfaces and #interfaces > 0 then\
        for _, interface in ipairs(interfaces) do\
            local details = hs.wifi.interfaceDetails(interface)\
            if details and details.ssid then\
                return details.ssid\
            end\
        end\
    end\
    \
    -- Method 3: Use airport command (no permission needed)\
    local output, status = hs.execute("/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | grep ' SSID' | awk '\{print $2\}'")\
    if status and output then\
        local ssid = output:match("^%s*(.-)%s*$")\
        if ssid and ssid ~= "" then return ssid end\
    end\
    \
    return nil\
end\
\
-- Check if any Ethernet interface has IPv4\
local function hasActiveEthernet()\
    local interfaces = hs.network.interfaces()\
    log("=== Checking Ethernet ===")\
    \
    for _, interface in ipairs(interfaces) do\
        -- Check interfaces starting with "en" (Ethernet interfaces)\
        if interface:match("^en%d+$") then\
            local details = hs.network.interfaceDetails(interface)\
            \
            if details then\
                local hasIPv4 = (details.IPv4 ~= nil)\
                local isAirPort = (details.AirPort ~= nil)\
                \
                log(string.format("  %s: IPv4=%s, AirPort=%s", \
                    interface, tostring(hasIPv4), tostring(isAirPort)))\
                \
                -- If it has IPv4 and is NOT WiFi, it's active Ethernet\
                if hasIPv4 and not isAirPort then\
                    log(string.format("
\f1 \uc0\u10003 
\f0  Active Ethernet found on %s", interface))\
                    return true\
                end\
            else\
                log(string.format("  %s: no details", interface))\
            end\
        end\
    end\
    \
    log("
\f2 \uc0\u10007 
\f0  No active Ethernet found")\
    return false\
end\
\
-- Check if network conditions are met (WiFi OR Ethernet)\
local function isNetworkOk()\
    log("=== Network Check ===")\
    \
    -- Check WiFi\
    local currentWiFi = getWiFiNetwork()\
    log(string.format("WiFi: %s (need: %s)", tostring(currentWiFi), requiredWiFi))\
    \
    if currentWiFi == requiredWiFi then\
        log("
\f1 \uc0\u10003 
\f0  WiFi condition satisfied")\
        return true\
    end\
    \
    -- Check Ethernet\
    if hasActiveEthernet() then\
        return true\
    end\
    \
    log("
\f2 \uc0\u10007 
\f0  No network conditions met")\
    return false\
end\
\
-- Main logic\
local function manageApp()\
    log("========================================")\
    \
    -- Check conditions\
    local powerOk = (hs.battery.powerSource() == "AC Power")\
    local networkOk = isNetworkOk()\
    local shouldRun = powerOk and networkOk\
    \
    log(string.format("RESULT: Power=%s, Network=%s, ShouldRun=%s", \
        tostring(powerOk), tostring(networkOk), tostring(shouldRun)))\
    \
    -- Skip if no state change\
    if shouldRun == lastShouldBeRunning then\
        log("No state change - skipping")\
        return\
    end\
    \
    lastShouldBeRunning = shouldRun\
    local app = hs.appfinder.appFromName(appName)\
    \
    if shouldRun and not app then\
        log("
\f1 \uc0\u8594 
\f0  LAUNCHING APP")\
        hs.application.launchOrFocus(appName)\
        notify(appName .. " opened")\
    elseif not shouldRun and app then\
        log("
\f1 \uc0\u8594 
\f0  KILLING APP")\
        app:kill()\
        notify(appName .. " closed")\
    end\
end\
\
-- Set up watchers\
local batteryWatcher = hs.battery.watcher.new(manageApp)\
local wifiWatcher = hs.wifi.watcher.new(manageApp)\
local reachabilityWatcher = hs.network.reachability.internet():setCallback(manageApp)\
\
local function handleWakeEvent(event)\
    if event == hs.caffeinate.watcher.systemDidWake then\
        hs.timer.doAfter(2, manageApp)\
    end\
end\
local wakeWatcher = hs.caffeinate.watcher.new(handleWakeEvent)\
\
-- Start watchers\
batteryWatcher:start()\
wifiWatcher:start()\
reachabilityWatcher:start()\
wakeWatcher:start()\
\
-- Initial check\
manageApp()\
notify("Automation loaded: " .. appName)}